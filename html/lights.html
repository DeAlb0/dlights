
<!DOCTYPE html>
<html lang="en">

<head>
  <meta name="description" content="flashing ligths to acompany the music" />
  <meta charset="utf-8">
  <title>Lights & Colors</title>
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <meta name="author" content="DeAlb0">
  <!-- link rel="stylesheet" href="css/style.css">
  <script src="http://code.jquery.com/jquery-latest.min.js"></script -->


<style>
    .light {
        border-radius : 50%;
        width : 1px;
        height: 1px;
        left : 50%;
        top : 50%;
        position: absolute;
        transition: 0.5s transform 0s;
    }
    .lights {
        position: static;
        display:block;
        width : 100%;
        height: 100%;
        overflow: hidden;
        background-color: black;
    }
    .lightrect {
        position:absolute;
        overflow: hidden;
        margin: 20px;
    }
    .light:not(.lighton) {
        /** turn afterflow off */
        background-color :hsl(0deg 90% 0%) !important;
    }

    .light.lighton {
        /*****
        width : 20vw;
        height: 20vw;
        *********/
        transform: scale(500);
        transition: 0.1s transform 0s;
    }
    body {
        background-color: black;
    }

</style>
<script>

var lightUpdateTime = 500
const lrows = 4
const lcols = 8
const lcount = lrows * lcols
var cycle = 0
var metacycle = 0
var diva = []


function mody(x,l,mode) {
    let period = l
    if ( mode === 1 ) {
        period = 2 * period - 2
    }
    const res = Math.abs(((Math.floor(x)+period)%period)-(mode*(l-1)))
    return res
}

let bunchx = 1
    let groupx = 1
    let bunchy = 1
    let buncht = 1
    let tmode = 1
    let fx = 1
    let fy = 0

cparameters = [
    { name: tmode, min: 0, max: 1},
    { name : bunchx, min : 0, max : 2}
]


function lightUpdate() {
    let max = fx*Math.floor(lcols/bunchx)+fy*Math.floor(lrows/bunchy) + groupx
        // on = (pos < max) && (pos + group > max)
    let tval = mody(cycle/buncht,max/2,tmode)
    for ( i = 0 ; i < lcount ; i++) {
        d = diva[i]
        let x = i % lcols
        let y = Math.floor(i / lcols)
//        let on = Math.max(((cycle - i) % lcount),((cycle - (lcount - i)) % lcount)) < (metacycle % lcount)
        // let on = ((cycle - i) % lcount) <= (metacycle % lcount) - 1  ^ ((cycle - (lcount - i - 1)) % lcount) <= (metacycle % lcount) - 1
        let pos = fx * Math.floor(x/bunchx) + fy * Math.floor(y/bunchy)
        // let on = ( tval - pos + max) % max < groupx
        let diffval = tval - mody(pos,max/2,1)
        let on = diffval < groupx && diffval >= 0
        let hue = mody(cycle/4 + y/2,max*4,0) * 120
        // hue = 0
        // d.innerText = "hue " + hue
        d.classList.toggle('lighton',on)
        // d.style.backgroundColor = `hsl(${(i % 6) * 60}deg 90% 50%)`
        d.style.backgroundColor = `hsl(${hue}deg 90% 50%)`
    }
    cycle++
    if ( cycle % lcount == 0 )metacycle++
    setTimeout(lightUpdate,lightUpdateTime)
    // if ( lightUpdateTime > 200 )    lightUpdateTime /= 1.1 
}

// TODO: fix with consistent columns and t row handling
const lcols2 = lcols
const lrows2 = lrows
function lights() {
    for ( base of document.querySelectorAll('.lights')) {
        let lcols = base.getAttribute('columns') || lcols2
        let lrows = base.getAttribute('rows') || lrows2
        for ( i = 0 ; i < lcount ; i++ ) {
            let ndiv = document.createElement('div')
            let ndivrect = document.createElement('div')
            ndiv.classList.add('light')
            ndivrect.classList.add('lightrect')
            ndiv.classList.add('light'+i)
            base.appendChild(ndivrect)
            ndivrect.appendChild(ndiv)
            diva.push(ndiv)
            // ndiv.style.left = `${(i % lcols + 0.5)*100/lcols}%`
            // ndiv.style.top = `${(Math.floor(i/lcols)+0.5)*100/lrows}%`
            ndivrect.style.left = `${(i % lcols)*100/lcols}%`
            ndivrect.style.top = `${(Math.floor(i/lcols))*100/lrows}%`
            ndivrect.style.width = `${100/lcols-1}%`
            ndivrect.style.height = `${100/lrows-1}%`
        }
    }
    setTimeout(lightUpdate,lightUpdateTime)
}
document.addEventListener("DOMContentLoaded", lights) 

var lastx = null
var lasty = null

function mmove(event) {
    y = event.y
    x = event.x
    if ( lastx === null ) {
        lastx = x
        lasty = y
    } else {
        let xdiff = x - lastx 
        lightUpdateTime = Math.max(50,xdiff + 500)
        lastx = x - (lightUpdateTime - 500)
    }
} 
addEventListener("mousemove", mmove);

</script>

</head>

<body>
  
<div class="lights">
  
</div>

<script>
</script>

</body>
</html>